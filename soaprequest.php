<?php

// Check the HTTP request for the keyword. Outside of testing purposes, I'd only be checking the GET method
if (!isset($_REQUEST['keyword'])) {

    return false;

} else {


    // Open up a database connection
    $conn = new mysqli('localhost', 'luketully', 'TNfn*9534', 'RegexService', '3306');

    // Start preparing a MySQL FULLTEXT match select statement to be later bound to
    $stmt1 = $conn->prepare("SELECT ExternalID,AuthorName,Title,Pattern,PositiveMatch,NegativeMatch,Description FROM Expressions WHERE MATCH (Title,Description) AGAINST (? IN BOOLEAN MODE)");

    // Get the keyword to search for from the HTTP request
    $keywordToPass = urldecode($_REQUEST['keyword']);

    if (!$stmt1) {
        echo "Prepare failed: (" . $conn->errno . ") " . $conn->error;

    } else {

        // Bind the keyword to search for to the select statement
        $stmt1->bind_param('s', $keywordToPass);

        // Execute the select statement
        if ($stmt1->execute()) {

            // Bind the results to $regexArray
            $stmt1->bind_result($regexArray['ExpressionId'], $regexArray['AuthorName'], $regexArray['Title'], $regexArray['Pattern'], $regexArray['MatchingText'], $regexArray['NonMatchingText'], $regexArray['Description']);

            // Pass the mysqli_stmt into function that will return an array of all the results
            if ($fullResults['NewDataSet']['Expressions'] = fetch($stmt1)) {

                // Print the results
                print_r(json_encode((object)$fullResults, JSON_HEX_TAG));
            } else {
                // If there were no results to select from the database, query the web service
                $client = new SoapClient('http://regexlib.com/webservices.asmx?WSDL', array('soap_version' => 1.2));

                // Use the listRegExp method generated by the WSDL file to ask for the specified regular expressions
                // The parameters are hardcoded in at the moment, but could easily be replaced sending
                // options along in the HTTP request
                $response = $client->listRegExp(array('keyword' => $keywordToPass, 'min_rating' => '-1', 'howmanyrows' => "162"));

                // The request will fail if spaces are not url-encoded
                $keywordVerify = replaceSpacesInUrl($_REQUEST['keyword']);

                // Convert the response received from the SOAP web service to JSON then again into an associative array
                $jsonResponse = json_decode(XML2JSON($responseAsXML = $response->listRegExpResult->any), true);

                // Create a new array of just the expressions
                $expressions = $jsonResponse['NewDataSet']['Expressions'];

                // Since there was the need to make a new request to the external service,
                // this request is inserted into the database. I'll be fixing this to work in a more logical and efficient way.
                // There is also no validation as of yet on what is put into the database.

                // Prepare the insert statement
                if (!$sql = $conn->prepare("INSERT into Expressions (ExternalID,AuthorName,Title,Pattern,PositiveMatch,NegativeMatch,Description) VALUES (?,?,?,?,?,?,?)")) {
                    echo "Prepare failed: (" . $conn->errno . ") " . $conn->error;
                }

                // Bind parameters to the statement
                $sql->bind_param('issssss', $ExternalID, $authorName, $patternTitle, $pattern, $positiveMatch, $negativeMatch, $description);

                // Execute an insert statement for each regular expression in the result set
                if ($expressions != null) {
                    foreach ($expressions as $item) {


                        $ExternalID = $item['ExpressionId'];
                        $authorName = $item['AuthorName'];
                        $patternTitle = $item['Title'];
                        $pattern = $item['Pattern'];
                        $positiveMatch = $item['MatchingText'];
                        $negativeMatch = $item['NonMatchingText'];
                        $description = $item['Description'];

                        $sql->execute();
                    }
                }
            }

        } else {
            // If for whatever reason the databse query fails,
            // try to perform the same external web service call as a fallback

            // Create a new SoapClient object based on the WSDL file
            $client = new SoapClient('http://regexlib.com/webservices.asmx?WSDL', array('soap_version' => 1.2));

            // Decode the keyword from the url
            $keywordToPass = urldecode($_REQUEST['keyword']);

            // Query the external web service using the listRegExp method of the SoapClient
            $response = $client->listRegExp(array('keyword' => $keywordToPass, 'min_rating' => '-1', 'howmanyrows' => "162"));

            // Perform urlencoding on the spaces in the request keyword
            $keywordVerify = replaceSpacesInUrl($_REQUEST['keyword']);

            // Convert the result to JSON then to an associative array
            $jsonResponse = json_decode(XML2JSON($responseAsXML = $response->listRegExpResult->any), true);

            // Create an array of just the expressions part of the result
            $expressions = $jsonResponse['NewDataSet']['Expressions'];


            // Prepare the insert statement
            if (!$sql = $conn->prepare("INSERT into Expressions (ExternalID,AuthorName,Title,Pattern,PositiveMatch,NegativeMatch,Description) VALUES (?,?,?,?,?,?,?)")) {
                echo "Prepare failed: (" . $conn->errno . ") " . $conn->error;
            }

            // Bind parameters to the statement
            $sql->bind_param('issssss', $ExternalID, $authorName, $patternTitle, $pattern, $positiveMatch, $negativeMatch, $description);

            // Execute an insert statement for each regular expression in the result set
            if ($expressions != null) {


                foreach ($expressions as $item) {


                    $ExternalID = $item['ExpressionId'];
                    $authorName = $item['AuthorName'];
                    $patternTitle = $item['Title'];
                    $pattern = $item['Pattern'];
                    $positiveMatch = $item['MatchingText'];
                    $negativeMatch = $item['NonMatchingText'];
                    $description = $item['Description'];

                    $sql->execute();
                }
            }

        }


    }
}

// Purpose: Perform urlencoding on spaces in the url parameter
function replaceSpacesInUrl($urlParameter)
{
    return preg_replace('#[ ]#', '%20', $urlParameter);

}

// Purpose: Workaround for how bind_param works. Will return an array containing all of the results from a select statement
function fetch($result)
{
    $array = array();

    if ($result instanceof mysqli_stmt) {
        $result->store_result();

        $variables = array();
        $data = array();
        $meta = $result->result_metadata();

        while ($field = $meta->fetch_field())
            $variables[] = & $data[$field->name]; // pass by reference

        call_user_func_array(array($result, 'bind_result'), $variables);

        $i = 0;
        while ($result->fetch()) {
            $array[$i] = array();
            foreach ($data as $k => $v)
                $array[$i][$k] = $v;
            $i++;

        }
    } elseif ($result instanceof mysqli_result) {
        while ($row = $result->fetch_assoc())
            $array[] = $row;
    }

    return $array;
}

// Converts an XML object to JSON

function XML2JSON($xml)
{

    function normalizeSimpleXML($obj, &$result)
    {
        $data = $obj;
        if (is_object($data)) {
            $data = get_object_vars($data);
        }
        if (is_array($data)) {
            foreach ($data as $key => $value) {
                $res = null;
                normalizeSimpleXML($value, $res);
                if (($key == '@attributes') && ($key)) {
                    $result = $res;
                } else {
                    $result[$key] = $res;
                }
            }
        } else {
            $result = $data;
        }
    }

    normalizeSimpleXML(simplexml_load_string($xml), $result);
    return json_encode($result);
}

?>
